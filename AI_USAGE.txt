# /main.py
  - Afficher un element
    def show_frame(self, page_name):
        frame = self.frames[page_name]
        frame.tkraise()

# ui/page_programmation_lineaire.py
  - Verifier si les matrices des coefficients(inputs_A) et des seconds membres(inputs_b) sont completes et valides avec :
    def verifier_inputs(self):
        # Verifier inputs_A
        for key, entry in self.inputs_A.items():
            if entry.get().strip() == "":
                print(f"L'entrée {key} dans A est vide !")
                return False

        # Verifier inputs_b
        for key, entry in self.inputs_b.items():
            if entry.get().strip() == "":
                print(f"L'entrée {key} dans b est vide !")
                return False

        print("Toutes les Entry sont remplies !")
        return True

  - Gerer l'input de "n",entrer par l'utilisateur, pour que ca soit un entier si ce n'est pas le cas la fonction return 0
    try:
        n = int(val)
    except ValueError:
            print("Veuillez entrer un nombre entier !")
            return 0

# ui/page_regression_lineaire.py
  - Supprimer un element avec son index de la liste contrainte_liste
    def suppr_contrainte(self, index):
        # Supprimer la contrainte graphiquement
        contrainte = self.contrainte_list.pop(index - 1)
        for widget in contrainte:
            widget.destroy()

        # Reindexer les autres contraintes pour eviter le decalage
        for i, contrainte in enumerate(self.contrainte_list, start=1):
            btn = contrainte[-1]
            btn.config(text=f"-{i}", command=lambda i=i: self.suppr_contrainte(i))

# core/prog_lineaire.py
  - Afficher en graphique les contraintes et les donnees optimals
    def afficher_graph(contrainte_data_list=None, data_optimal=None):
      if contrainte_data_list is None:
          contrainte_data_list = []
      
      x_vals = np.linspace(0, 10, 400)
      
      plt.figure(figsize=(7, 7))
      
      # Tracer chaque contrainte
      for c in contrainte_data_list:
          a, b = c["coefficient"]
          signe = c["signe"]
          c_val = c["second_membre"]
          
          if b != 0:
              y = (c_val - a * x_vals) / b
              plt.plot(x_vals, y, label=f'{a}x + {b}y {signe} {c_val}')
          else:  # cas vertical x = c_val / a
              x = np.full_like(x_vals, c_val / a)
              plt.plot(x, x_vals, label=f'{a}x + {b}y {signe} {c_val}')
      
      # Définir limites selon contraintes
      plt.xlim(0, max(10, max([c["second_membre"] for c in contrainte_data_list])))
      plt.ylim(0, max(10, max([c["second_membre"] for c in contrainte_data_list])))
      
      # Tracer le point optimal
      if data_optimal:
          plt.scatter(data_optimal["x_max"], data_optimal["y_max"], color='red', s=100, label='Optimum')
          plt.text(data_optimal["x_max"], data_optimal["y_max"]+0.3,
                  f'({data_optimal["x_max"]}, {data_optimal["y_max"]})', color='red')
      plt.xlabel("x")
      plt.ylabel("y")
      plt.title("Graphique des contraintes et point optimal")
      plt.grid(True)
      plt.legend()
      plt.show()
